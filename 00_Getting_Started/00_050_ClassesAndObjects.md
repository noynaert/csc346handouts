# 00.050 Classes and Objects

I am assuming that everyone has a basic understanding of Objects and classes.

Some people may need a review.  We also went through a major course realignment.  We also have people who transferred in their basic Java.  

The intent of this unit is to get everyone oriented to the Java standard practices for Class definitions.

This review will also cover implementation of the Comparable&lt;Object> Interface.

## Standard class components

* Each public class in a file
* JavaDoc comment(s)
* Setters
* Getters
* Constructor(s)
* toString()
  * toString should not include a \n 
* compareTo()
* equals() and hashCode() written by the IDE

* Javadoc comments before the class should include a description of the class and `@author` and `@since` clauses.  The @since should show the month and year the class was started.  The standard class members do not need their own JavaDoc comments, but methods that do not follow the normal pattern should have their own JavaDoc.
* Data members are private
* Constructors should either call other constructors or setters to assign initial values to data fields
* Fields should have getters and setters in standard format
* There should be a toString method
* When the Comparable&lt;Object> interface is declared, the compareTo method must be implemented.
* The equals() and hashCode() methods should be generated by the IDE in accordance with the Java Contract.


### JavaDoc Comments

```java
/**
 * The Person class is a simple illustration of a basic class
 * 
 * If the person's age is greater than 115 or less than 0 the age is set to -1.  
 * -1 is the flag for age unknown
 * 
 * @author J. Evan Noynaert
 * @since December 2021
 * 
 */
 ```

 ### Class declaration

 Note that this is in a separate file in the `src` folder.

 ```java
 public class Person implements Comparable<Person>{
```

### Data members

Data members should be declared as `private` until later in the course when we consider other modifiers.

```java
    private String firstName;
    private String lastName;
    private int age;
```

### Setters

Setters are gatekeepers for the private data members.  They make sure that all values are valid.  

All data members should have public setters unless there is a reason not to.  

Setters have void return data types. 

The accepted style is to use the name of the field as the parameter.  Using the same id means that the `this.` modifier must be used to resolve the ambiguity.

Note that setAge only allows valid ages to be entered.  Invalid ages are listed as a -1.  It might have been better to set a boolean field for age, but this is how I decided to do it.

```java
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public void setLastName(String lastName) { 
        this.lastName = lastName;
    }

    /**
     * * If the person's age is greater than 115 or less than 0 the age is set to
     * -1.
     * -1 is the flag for age unknown
     * 
     * @param age  Age must be 0 through 115.  Ages outside that range are flag as age unknown.
     */
    public void setAge(int age) {
        // if(age < 0 || age > 115)
        //     this.age = -1;
        // else
        //     this.age = age;

        this.age = (age < 0 || age > 115) ? -1 : age;
    }
```

### Constructors

Constructors should call the setters rather than setting the data fields directly.  This means there is only one point of maintenance.

Note that the first constructor is the most detailed.  Other constructors may call the detailed constructor.  One of my main motives for this is to illustrate the use of `this` to call the same-class constructors.  This foreshadows the use of `super` when we explore inheritance.

Setters should normally appear first in the declarations, right after the data members.

In the example I included a "no arg" constructor.  It is not necessary to do this in Java.  

```java
public Person(String firstName, String lastName, int age) {
        setFirstName(firstName);
        setLastName(lastName);
        setAge(age);
    }

    public Person(String firstName, String lastName) {
        this(firstName, lastName, -99);
    }

    public Person() {
        this("Anonymous", "Coward", 117);
    }
```

### Getters

The Getters are the easiest methods to write.  They simply return the value of the data field in most cases.

```java
 public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return this.lastName;  //the this. is not necessary
    }

    public int getAge() {
        return age;
    }
```

### toString

Every object should know how to return a string representing itself.  The Object class in Java has a default toString() method.  Therefore our custom class uses the @Override decorator.

Note a couple of things people often do wrong in coding:

* The toString() method does not print!  Never!  It should return a string.  The use may invoke toString() for reasons other than printing.
* The toString should not normally have a \n appended to it.  The user may be doing something like presenting the toString in a table and the automatic \n would be a problem.  


```java
    @Override
    public String toString() {
        String s = String.format("%s, %s", lastName, firstName);
        if (age > -1)
            s += String.format("  Age: %d", age);
        return s;
    }
```

### compareTo

The Comparable&lt; > interface requires the compareTo method to be implemented.  The `@Override` decorator is required because we are overriding the method in the Comparable&lt; > interface.

In the Person class the compareTo tries to use the last name.  If the last names are the same, then it attempts to break the tie on first names.  If the first names are a tie, then the tie is broken on age.

Note that `this.` is not required.  But I elected to use it to improve readability.

```java
    @Override
    public int compareTo(Person other) {
        int result = this.lastName.compareTo(other.lastName);
        if (result == 0) {
            result = this.firstName.compareTo(other.firstName);
        }
        if (result == 0) {
            result = this.age - other.age;
        }
        return result;
    }
```

### equals and hashCode

Equals and hasCode are linked.  If either is defined then the other must also be defined.  By the Java Contract, if two objects are equal then they must have the same hashCode.  (But the reverse is not true.  If two objects have the same hashCode they *might not* be equal.  But it is extremely unlikely that two hashcodes would be equal if unless the objects are equal).

Generally it is best to leave generation of equals an hashCode methods to the IDE unless you really know what you are doing.




